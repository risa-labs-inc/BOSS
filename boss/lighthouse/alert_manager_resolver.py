"""AlertManagerResolver for centralized alert management.

This resolver provides centralized alert management capabilities for the BOSS system,
handling alert routing, filtering, aggregation, and notification delivery. It works
closely with the MonitoringResolver to manage alerts generated by the system.
"""

import os
import json
import smtplib
import logging
import asyncio
import traceback
from email.message import EmailMessage
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Set, Union, cast

from boss.core.task_models import Task, TaskResult
from boss.core.task_resolver import TaskResolver, TaskResolverMetadata
from boss.core.task_status import TaskStatus


class AlertManagerResolver(TaskResolver):
    """Resolver for centralized alert management.
    
    This resolver supports various alert management operations including:
    - Alert routing to appropriate channels
    - Alert filtering and deduplication
    - Alert aggregation
    - Notification delivery via email, SMS, webhook, etc.
    - Alert acknowledgment and resolution tracking
    
    Attributes:
        boss_home_dir: The home directory of the BOSS instance
        alerts_dir: Directory for storing alerts
        config_file: Path to the alert manager configuration file
        notification_channels: Dictionary of configured notification channels
        routing_rules: Rules for routing alerts to notification channels
        alert_history_days: Number of days to keep alert history
    """
    
    def __init__(self, metadata: TaskResolverMetadata) -> None:
        """Initialize the AlertManagerResolver.
        
        Args:
            metadata: Resolver metadata
        """
        super().__init__(metadata)
        self.boss_home_dir = os.environ.get("BOSS_HOME", os.getcwd())
        self.alerts_dir = os.path.join(self.boss_home_dir, "data", "alerts")
        self.config_file = os.path.join(self.boss_home_dir, "config", "alert_manager.json")
        
        # Create directories if they don't exist
        os.makedirs(self.alerts_dir, exist_ok=True)
        os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
        
        # Default configuration
        self.notification_channels = {
            "email": {
                "enabled": False,
                "smtp_server": "",
                "smtp_port": 587,
                "smtp_username": "",
                "smtp_password": "",
                "from_address": "",
                "recipients": []
            },
            "webhook": {
                "enabled": False,
                "url": "",
                "headers": {},
                "method": "POST"
            },
            "console": {
                "enabled": True
            }
        }
        
        self.routing_rules = {
            "critical": ["email", "webhook", "console"],
            "error": ["email", "console"],
            "warning": ["console"],
            "info": ["console"]
        }
        
        self.alert_history_days = 30
        
        # Load configuration if it exists
        self.load_config()
        
        self.logger = logging.getLogger(__name__)

    def load_config(self) -> None:
        """Load the alert manager configuration from the config file."""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    self.notification_channels = config.get(
                        "notification_channels", self.notification_channels
                    )
                    self.routing_rules = config.get("routing_rules", self.routing_rules)
                    self.alert_history_days = config.get(
                        "alert_history_days", self.alert_history_days
                    )
            except Exception as e:
                self.logger.error(f"Error loading alert manager config: {e}")

    def save_config(self) -> None:
        """Save the current alert manager configuration to the config file."""
        try:
            config = {
                "notification_channels": self.notification_channels,
                "routing_rules": self.routing_rules,
                "alert_history_days": self.alert_history_days
            }
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=4)
        except Exception as e:
            self.logger.error(f"Error saving alert manager config: {e}")

    async def resolve(self, task: Task) -> TaskResult:
        """Resolve the task based on its description.
        
        Args:
            task: The task to resolve
            
        Returns:
            The task result with the outcome of the alert management operation
        """
        try:
            if not isinstance(task.input_data, dict):
                return TaskResult(
                    task_id=task.id,
                    status=TaskStatus.ERROR,
                    output_data={"error": "Input data must be a dictionary"}
                )
                
            operation = task.input_data.get("operation")
            if not operation:
                return TaskResult(
                    task_id=task.id,
                    status=TaskStatus.ERROR,
                    output_data={"error": "Missing 'operation' field in input data"}
                )
            
            # Handle different operations
            if operation == "process_alert":
                return await self._handle_process_alert(task)
            elif operation == "configure_channel":
                return await self._handle_configure_channel(task)
            elif operation == "update_routing_rules":
                return await self._handle_update_routing_rules(task)
            elif operation == "get_active_alerts":
                return await self._handle_get_active_alerts(task)
            elif operation == "acknowledge_alert":
                return await self._handle_acknowledge_alert(task)
            elif operation == "resolve_alert":
                return await self._handle_resolve_alert(task)
            elif operation == "get_alert_history":
                return await self._handle_get_alert_history(task)
            elif operation == "clear_old_alerts":
                return await self._handle_clear_old_alerts(task)
            elif operation == "test_notification_channel":
                return await self._handle_test_notification_channel(task)
            elif operation == "health_check":
                return await self._handle_health_check(task)
            else:
                return TaskResult(
                    task_id=task.id,
                    status=TaskStatus.ERROR,
                    output_data={"error": f"Unsupported operation: {operation}"}
                )
                
        except Exception as e:
            self.logger.error(f"Error in AlertManagerResolver: {e}")
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={
                    "error": f"Internal error: {str(e)}",
                    "traceback": str(traceback.format_exc())
                }
            )

    async def _handle_process_alert(self, task: Task) -> TaskResult:
        """Process an incoming alert and route it to appropriate channels.
        
        Args:
            task: The task containing the alert data
            
        Returns:
            The task result with the outcome of the alert processing
        """
        alert_data = task.input_data.get("alert", {})
        if not alert_data:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": "Alert data is missing or empty"}
            )
            
        # Required alert fields
        required_fields = ["id", "severity", "title", "message", "source"]
        missing_fields = [field for field in required_fields if field not in alert_data]
        if missing_fields:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={
                    "error": f"Alert data is missing required fields: {', '.join(missing_fields)}",
                    "alert_data": alert_data
                }
            )
            
        # Add timestamp if not present
        if "timestamp" not in alert_data:
            alert_data["timestamp"] = datetime.now().isoformat()
            
        # Set status to "active" if not present
        if "status" not in alert_data:
            alert_data["status"] = "active"
            
        # Store the alert
        await self._store_alert(alert_data)
        
        # Route the alert to appropriate channels
        severity = alert_data.get("severity", "")
        channels = self.routing_rules.get(severity, [])
        
        delivery_results = []
        for channel in channels:
            try:
                channel_config = self.notification_channels.get(channel, {})
                if channel in self.notification_channels and channel_config.get("enabled", False):
                    result = await self._send_to_channel(channel, alert_data)
                    delivery_results.append({
                        "channel": channel,
                        "success": result.get("success", False),
                        "message": result.get("message", "")
                    })
            except Exception as e:
                delivery_results.append({
                    "channel": channel,
                    "success": False,
                    "message": f"Error sending to channel: {str(e)}"
                })
                
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "alert_id": alert_data.get("id", ""),
                "status": "processed",
                "delivery_results": delivery_results
            }
        )

    async def _handle_configure_channel(self, task: Task) -> TaskResult:
        """Configure a notification channel.
        
        Args:
            task: The task containing channel configuration data
            
        Returns:
            The task result with the outcome of the configuration
        """
        channel_type = task.input_data.get("channel_type", "")
        config = task.input_data.get("config", {})
        
        if not channel_type or not config:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": "Channel type or configuration is missing"}
            )
            
        if channel_type not in self.notification_channels:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={
                    "error": f"Unsupported channel type: {channel_type}",
                    "supported_channels": list(self.notification_channels.keys())
                }
            )
            
        # Update channel configuration
        channel_config = self.notification_channels.get(channel_type, {})
        if isinstance(channel_config, dict) and isinstance(config, dict):
            for key, value in config.items():
                channel_config[key] = value
            self.notification_channels[channel_type] = channel_config
            
        # Save the updated configuration
        self.save_config()
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "channel_type": channel_type,
                "status": "configured",
                "config": self.notification_channels.get(channel_type, {})
            }
        )

    async def _handle_update_routing_rules(self, task: Task) -> TaskResult:
        """Update the routing rules for alerts.
        
        Args:
            task: The task containing the routing rules update
            
        Returns:
            The task result with the outcome of the update
        """
        routing_rules = task.input_data.get("routing_rules", {})
        
        if not routing_rules:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": "Routing rules are missing or empty"}
            )
            
        # Validate that all channels exist
        all_channels = set(self.notification_channels.keys())
        for severity, channels in routing_rules.items():
            if not isinstance(channels, list):
                return TaskResult(
                    task_id=task.id,
                    status=TaskStatus.ERROR,
                    output_data={
                        "error": f"Channels for severity '{severity}' must be a list",
                        "invalid_value": channels
                    }
                )
                
            invalid_channels = [c for c in channels if c not in all_channels]
            if invalid_channels:
                return TaskResult(
                    task_id=task.id,
                    status=TaskStatus.ERROR,
                    output_data={
                        "error": f"Invalid channels in routing rules: {', '.join(invalid_channels)}",
                        "valid_channels": list(all_channels)
                    }
                )
                
        # Update routing rules
        for severity, channels in routing_rules.items():
            self.routing_rules[severity] = channels
        
        # Save the updated configuration
        self.save_config()
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "status": "updated",
                "routing_rules": self.routing_rules
            }
        )

    async def _handle_get_active_alerts(self, task: Task) -> TaskResult:
        """Get all active alerts.
        
        Args:
            task: The task requesting active alerts
            
        Returns:
            The task result with the active alerts
        """
        filters = task.input_data.get("filters", {})
        
        # Get all alerts
        alerts = await self._load_alerts()
        
        # Filter active alerts
        active_alerts = [
            alert for alert in alerts 
            if alert.get("status") == "active"
        ]
        
        # Apply additional filters if provided
        if filters and isinstance(filters, dict):
            for key, value in filters.items():
                if key in ["severity", "source"]:
                    active_alerts = [
                        alert for alert in active_alerts 
                        if alert.get(key) == value
                    ]
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "alerts": active_alerts,
                "count": len(active_alerts)
            }
        )

    async def _handle_acknowledge_alert(self, task: Task) -> TaskResult:
        """Acknowledge an alert.
        
        Args:
            task: The task containing the alert ID to acknowledge
            
        Returns:
            The task result with the outcome of the acknowledgment
        """
        alert_id = task.input_data.get("alert_id", "")
        acknowledged_by = task.input_data.get("acknowledged_by", "system")
        
        if not alert_id:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": "Alert ID is missing"}
            )
            
        # Get all alerts
        alerts = await self._load_alerts()
        
        # Find the alert to acknowledge
        found = False
        for i, alert in enumerate(alerts):
            if alert.get("id") == alert_id and alert.get("status") == "active":
                alerts[i]["status"] = "acknowledged"
                alerts[i]["acknowledged_at"] = datetime.now().isoformat()
                alerts[i]["acknowledged_by"] = acknowledged_by
                found = True
                break
                
        if not found:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": f"Active alert with ID {alert_id} not found"}
            )
            
        # Save the updated alerts
        await self._save_alerts(alerts)
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "alert_id": alert_id,
                "status": "acknowledged",
                "acknowledged_at": datetime.now().isoformat(),
                "acknowledged_by": acknowledged_by
            }
        )

    async def _handle_resolve_alert(self, task: Task) -> TaskResult:
        """Resolve an alert.
        
        Args:
            task: The task containing the alert ID to resolve
            
        Returns:
            The task result with the outcome of the resolution
        """
        alert_id = task.input_data.get("alert_id", "")
        resolved_by = task.input_data.get("resolved_by", "system")
        resolution_note = task.input_data.get("resolution_note", "")
        
        if not alert_id:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": "Alert ID is missing"}
            )
            
        # Get all alerts
        alerts = await self._load_alerts()
        
        # Find the alert to resolve
        found = False
        for i, alert in enumerate(alerts):
            status = alert.get("status", "")
            if alert.get("id") == alert_id and status in ["active", "acknowledged"]:
                alerts[i]["status"] = "resolved"
                alerts[i]["resolved_at"] = datetime.now().isoformat()
                alerts[i]["resolved_by"] = resolved_by
                if resolution_note:
                    alerts[i]["resolution_note"] = resolution_note
                found = True
                break
                
        if not found:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": f"Active or acknowledged alert with ID {alert_id} not found"}
            )
            
        # Save the updated alerts
        await self._save_alerts(alerts)
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "alert_id": alert_id,
                "status": "resolved",
                "resolved_at": datetime.now().isoformat(),
                "resolved_by": resolved_by,
                "resolution_note": resolution_note
            }
        )

    async def _handle_get_alert_history(self, task: Task) -> TaskResult:
        """Get the alert history.
        
        Args:
            task: The task requesting alert history
            
        Returns:
            The task result with the alert history
        """
        days = task.input_data.get("days", 7)
        filters = task.input_data.get("filters", {})
        
        # Get all alerts
        alerts = await self._load_alerts()
        
        # Filter by time range
        cutoff_date = (datetime.now() - timedelta(days=days)).isoformat()
        filtered_alerts = [
            alert for alert in alerts 
            if alert.get("timestamp", "") >= cutoff_date
        ]
        
        # Apply additional filters if provided
        if filters and isinstance(filters, dict):
            for key, value in filters.items():
                if key in ["severity", "source", "status"]:
                    filtered_alerts = [
                        alert for alert in filtered_alerts 
                        if alert.get(key) == value
                    ]
        
        # Sort by timestamp (newest first)
        filtered_alerts.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "alerts": filtered_alerts,
                "count": len(filtered_alerts),
                "time_range": f"Last {days} days"
            }
        )

    async def _handle_clear_old_alerts(self, task: Task) -> TaskResult:
        """Clear old alerts based on the alert history configuration.
        
        Args:
            task: The task requesting to clear old alerts
            
        Returns:
            The task result with the outcome of the operation
        """
        days = task.input_data.get("days", self.alert_history_days)
        
        # Get all alerts
        alerts = await self._load_alerts()
        
        # Calculate cutoff date
        cutoff_date = (datetime.now() - timedelta(days=days)).isoformat()
        
        # Filter out old alerts
        new_alerts = [
            alert for alert in alerts 
            if alert.get("timestamp", "") >= cutoff_date
        ]
        
        # Count removed alerts
        removed_count = len(alerts) - len(new_alerts)
        
        # Save the updated alerts
        if removed_count > 0:
            await self._save_alerts(new_alerts)
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "status": "completed",
                "removed_alerts": removed_count,
                "remaining_alerts": len(new_alerts),
                "cutoff_date": cutoff_date
            }
        )

    async def _handle_test_notification_channel(self, task: Task) -> TaskResult:
        """Test a notification channel with a test alert.
        
        Args:
            task: The task containing the channel to test
            
        Returns:
            The task result with the outcome of the test
        """
        channel_type = task.input_data.get("channel_type", "")
        
        if not channel_type:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": "Channel type is missing"}
            )
            
        if channel_type not in self.notification_channels:
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={
                    "error": f"Unsupported channel type: {channel_type}",
                    "supported_channels": list(self.notification_channels.keys())
                }
            )
            
        channel_config = self.notification_channels.get(channel_type, {})
        if not channel_config.get("enabled", False):
            return TaskResult(
                task_id=task.id,
                status=TaskStatus.ERROR,
                output_data={"error": f"Channel {channel_type} is disabled"}
            )
            
        # Create a test alert
        test_alert = {
            "id": f"test-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            "severity": "info",
            "title": "Test Alert",
            "message": f"This is a test alert for the {channel_type} channel",
            "source": "AlertManagerResolver",
            "timestamp": datetime.now().isoformat(),
            "status": "test"
        }
        
        # Send the test alert to the specified channel
        result = await self._send_to_channel(channel_type, test_alert)
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data={
                "channel_type": channel_type,
                "test_alert": test_alert,
                "delivery_result": result
            }
        )

    async def _handle_health_check(self, task: Task) -> TaskResult:
        """Perform a health check on the AlertManagerResolver.
        
        Args:
            task: The health check task
            
        Returns:
            The task result with health check results
        """
        health_status = {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "checks": {
                "configuration": self._check_configuration_health(),
                "alerts_directory": os.path.exists(self.alerts_dir),
                "channels": {}
            }
        }
        
        # Check if we can read/write alerts
        try:
            test_alerts = await self._load_alerts()
            health_status["checks"]["alerts_readable"] = True
        except Exception:
            health_status["checks"]["alerts_readable"] = False
            health_status["status"] = "unhealthy"
            
        # Add channel health information
        for channel, config in self.notification_channels.items():
            if isinstance(config, dict) and config.get("enabled", False):
                try:
                    # Just basic validation of configuration, not actual connectivity
                    if channel == "email":
                        email_config = config
                        has_required = all(
                            key in email_config and email_config.get(key) 
                            for key in ["smtp_server", "smtp_port", "from_address", "recipients"]
                        )
                        health_status["checks"]["channels"][channel] = has_required
                    elif channel == "webhook":
                        webhook_config = config
                        has_required = "url" in webhook_config and webhook_config.get("url")
                        health_status["checks"]["channels"][channel] = has_required
                    else:
                        health_status["checks"]["channels"][channel] = True
                except Exception:
                    health_status["checks"]["channels"][channel] = False
                    health_status["status"] = "unhealthy"
            else:
                health_status["checks"]["channels"][channel] = None  # Disabled
        
        return TaskResult(
            task_id=task.id,
            status=TaskStatus.COMPLETED,
            output_data=health_status
        )

    async def _send_to_channel(self, channel: str, alert: Dict[str, Any]) -> Dict[str, Any]:
        """Send an alert to a notification channel.
        
        Args:
            channel: The channel to send the alert to
            alert: The alert data
            
        Returns:
            A dictionary with the result of the sending operation
        """
        if channel == "email":
            return await self._send_email(alert)
        elif channel == "webhook":
            return await self._send_webhook(alert)
        elif channel == "console":
            return self._send_console(alert)
        else:
            return {
                "success": False,
                "message": f"Unsupported channel: {channel}"
            }

    async def _send_email(self, alert: Dict[str, Any]) -> Dict[str, Any]:
        """Send an alert via email.
        
        Args:
            alert: The alert data
            
        Returns:
            A dictionary with the result of the sending operation
        """
        config = self.notification_channels.get("email", {})
        try:
            severity = alert.get("severity", "").upper()
            title = alert.get("title", "")
            message = alert.get("message", "")
            source = alert.get("source", "")
            timestamp = alert.get("timestamp", "")
            alert_id = alert.get("id", "")
            
            # Create email message
            msg = EmailMessage()
            msg['Subject'] = f"[{severity}] {title}"
            
            from_address = config.get("from_address", "")
            if not from_address:
                return {
                    "success": False,
                    "message": "From address is not configured"
                }
            msg['From'] = from_address
            
            recipients = config.get("recipients", [])
            if not recipients:
                return {
                    "success": False,
                    "message": "No recipients configured"
                }
            msg['To'] = ", ".join(recipients)
            
            # Create email body
            body = f"""
Alert Details:
--------------
Severity: {severity}
Title: {title}
Message: {message}
Source: {source}
Timestamp: {timestamp}
ID: {alert_id}
"""
            msg.set_content(body)
            
            # Send email
            smtp_server = config.get("smtp_server", "")
            smtp_port = config.get("smtp_port", 587)
            
            if not smtp_server:
                return {
                    "success": False,
                    "message": "SMTP server is not configured"
                }
                
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                smtp_username = config.get("smtp_username")
                smtp_password = config.get("smtp_password")
                
                if smtp_username and smtp_password:
                    server.starttls()
                    server.login(smtp_username, smtp_password)
                server.send_message(msg)
                
            return {
                "success": True,
                "message": f"Email sent to {len(recipients)} recipients"
            }
        except Exception as e:
            self.logger.error(f"Error sending email: {e}")
            return {
                "success": False,
                "message": f"Error sending email: {str(e)}"
            }

    async def _send_webhook(self, alert: Dict[str, Any]) -> Dict[str, Any]:
        """Send an alert via webhook.
        
        Args:
            alert: The alert data
            
        Returns:
            A dictionary with the result of the sending operation
        """
        import aiohttp
        
        config = self.notification_channels.get("webhook", {})
        try:
            # Create webhook payload
            payload = {
                "alert": alert
            }
            
            url = config.get("url", "")
            if not url:
                return {
                    "success": False,
                    "message": "Webhook URL is not configured"
                }
                
            method = config.get("method", "POST")
            headers = config.get("headers", {})
            
            # Send webhook request
            async with aiohttp.ClientSession() as session:
                async with session.request(
                    method=method,
                    url=url,
                    json=payload,
                    headers=headers
                ) as response:
                    if response.status < 400:
                        return {
                            "success": True,
                            "message": f"Webhook sent with status {response.status}"
                        }
                    else:
                        return {
                            "success": False,
                            "message": f"Webhook failed with status {response.status}"
                        }
        except Exception as e:
            self.logger.error(f"Error sending webhook: {e}")
            return {
                "success": False,
                "message": f"Error sending webhook: {str(e)}"
            }

    def _send_console(self, alert: Dict[str, Any]) -> Dict[str, Any]:
        """Send an alert to the console.
        
        Args:
            alert: The alert data
            
        Returns:
            A dictionary with the result of the sending operation
        """
        severity = alert.get("severity", "").upper()
        title = alert.get("title", "")
        message = alert.get("message", "")
        timestamp = alert.get("timestamp", "")
        
        log_message = f"[{severity}] {timestamp} - {title}: {message}"
        
        if severity == "CRITICAL":
            self.logger.critical(log_message)
        elif severity == "ERROR":
            self.logger.error(log_message)
        elif severity == "WARNING":
            self.logger.warning(log_message)
        else:
            self.logger.info(log_message)
            
        return {
            "success": True,
            "message": "Alert logged to console"
        }

    async def _store_alert(self, alert: Dict[str, Any]) -> None:
        """Store an alert in the alerts directory.
        
        Args:
            alert: The alert to store
        """
        # Load existing alerts
        alerts = await self._load_alerts()
        
        # Check if alert with this ID already exists
        alert_id = alert.get("id")
        if alert_id:
            for i, existing_alert in enumerate(alerts):
                if existing_alert.get("id") == alert_id:
                    # Update existing alert
                    alerts[i] = alert
                    break
            else:
                # Add new alert
                alerts.append(alert)
        else:
            # Add new alert (no ID)
            alerts.append(alert)
            
        # Save alerts
        await self._save_alerts(alerts)

    async def _load_alerts(self) -> List[Dict[str, Any]]:
        """Load all alerts from the alerts file.
        
        Returns:
            A list of alert dictionaries
        """
        alerts_file = os.path.join(self.alerts_dir, "alerts.json")
        if not os.path.exists(alerts_file):
            return []
            
        try:
            with open(alerts_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Error loading alerts: {e}")
            return []

    async def _save_alerts(self, alerts: List[Dict[str, Any]]) -> None:
        """Save alerts to the alerts file.
        
        Args:
            alerts: The list of alerts to save
        """
        alerts_file = os.path.join(self.alerts_dir, "alerts.json")
        try:
            with open(alerts_file, 'w', encoding='utf-8') as f:
                json.dump(alerts, f, indent=2)
        except Exception as e:
            self.logger.error(f"Error saving alerts: {e}")

    def _check_configuration_health(self) -> bool:
        """Check if the configuration is healthy.
        
        Returns:
            True if the configuration is healthy, False otherwise
        """
        # Check if we have at least one enabled channel
        has_enabled_channel = any(
            isinstance(channel, dict) and channel.get("enabled", False)
            for channel in self.notification_channels.values()
        )
        
        # Check if we have routing rules for all severity levels
        has_routing_rules = all(
            severity in self.routing_rules
            for severity in ["critical", "error", "warning", "info"]
        )
        
        return has_enabled_channel and has_routing_rules

    async def health_check(self) -> bool:
        """Perform a health check on the AlertManagerResolver.
        
        Returns:
            True if the resolver is healthy, False otherwise
        """
        try:
            # Check if alerts directory exists
            if not os.path.exists(self.alerts_dir):
                return False
                
            # Check if we can load alerts
            await self._load_alerts()
            
            # Check configuration health
            if not self._check_configuration_health():
                return False
                
            return True
        except Exception:
            return False 